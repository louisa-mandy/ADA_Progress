import simpy 
import random 

SEED = 42 #ensures that the random numbers generated by Pythonâ€™s random module will be the same every time the program is run, as long as the seed value remains the same.
MACHINES = 2 # total number of machines 
INTERVAL = 10.0 # Mean time between thw two jobs 
DURATION = 5.0 # Mean processing time of a job 
JOBS = 10 # Total of jobs that need to be completed 

# Brute Force Approach!!!!!!!!!!!!!!
def production_brute_force(env, name, machines):

    #simulates job execution on the machine using Brute Force 
    with machines.request() as request:
        yield request
        print(f"{name} (Brute Force) started at time {env.now}")
        yield env.timeout(DURATION)
        print(f"{name} (Brute Force) completed at time {env.now}")
        

def generates_jobs_brute_force(env, machines):
    
    #Generates the jobs for brute approach
    for i in range(JOBS):
        yield env.timeout(random.expovariate(1.0 / INTERVAL))
        env.process(production_brute_force(env, f"job {i+1}", machines))

    
# Annealing Approach!!!!!!!!!!!!
def production_annealing(env, name, machine_id):

    #simulates job execution on the machine with annealing approach
    print(f"{name} (Annealing) assigned to Machine {machine_id} at time {env.now}")
    yield env.timeout(DURATION)
    print(f"{name} (Annealing) completed on Machine {machine_id} at time {env.now}")

def generates_jobs_annealing(env, schedule):
    #generates the jobs based on the optimized annealing schedule
    for job_id, machine_id, start_time in schedule:
        yield env.timeout(max(0, start_time - env.now)) # waiting for the schedules start time
        env.process(production_annealing(env, f"job {job_id}", machine_id))
    

# For the Annealing approach optimization
def annealing_schedule(jobs, machines):
    #makes an optimized schedule with simulated annealing
    random.seed(SEED)
    job_ids = list(range(1, jobs + 1))
    current_schedules = [(job_id, random.randint(0, machines - 1), random.uniform(0,50)) for job_id in job_ids]

    # for instance, replacing this wih an actual simulated anneling process in order to minimize makespan
    # this is to produce a simple schedule as an example

    current_schedules.sort(key=lambda x: x[2]) # sorting it by start time
    return current_schedules



# MAIN SIMULATION!!!!!!!!
random.seed(SEED)

# the brute force part for simulation 
print(" ")
print("___Brute Force Approach___")
env_brute = simpy.Environment()
machines_brute = simpy.Resource(env_brute, capacity=MACHINES)
env_brute.process(generates_jobs_brute_force(env_brute, machines_brute))
env_brute.run(until=100.0)
print(" ")

# the annealing part for simulation 
print(" ")
print("___Annealing Approach___")
env_annealing = simpy.Environment()
schedule = annealing_schedule(JOBS, MACHINES)
env_annealing.process(generates_jobs_annealing(env_annealing, schedule))
env_annealing.run(until=100.0)
print(" ")